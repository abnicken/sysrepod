 /* License : Apache 2.0
 *
 *  Created on: Jan 30, 2015
 *      Author: Niraj Sharma
 *      Cisco Systems, Inc.
 */


1) To build, use 'make'.
2) To clean, use 'make clean'.
3) To run server listening on 3500 port:
      cd server
      ./sysrepod param

   In another XTERM window start sample client that talks SRD (Sys Repo Daemon) protocol:
     cd client_SRD
     # To run client that issues a few commands and exits.
     ./clientsrd 
     # This client in the end will wait for a command from SysrepoD server requesting
     # information about the Operational Data Store that this client is maintaining.
     # There is a need of a North-bound client that initiates a request for Operational Data Store by
     # send it to SysrepoD server. The server in turn forwards that request to this client "./clientsrd.
     # To test this feature, it is time to start a sample North-Bound Client. To do that follow the following steps:
     # Start a new XTERM window and be in the code directory.
     cd client_SRD
     ./opDStoreClient
     # It will start this North-Side Management Client. You will see messages going to server and to 'clientsrd'
     # started earlier.         

4) One can run many clients in parallel from separate XTERM windows.
5) ClientSRD.cpp implements a client class that talks SRD protocol. One can create additional classes
   for different protocols by deriving from the base class Client implemented in Client.cpp.
6) mainSRDClient.cpp implements a sample client that talks SRD.
7) mainSysRedoD.cpp implements the SysRepo Daemon. 
8) DataStore.cpp implements the Data Store class. One can have many Data Stores.
9) libsrd.a is the library that any client talking SRD protocol will link with.
   To understand the API Calls available in libsrd.a, look at the file srd.h.
10) HOW TO WRITE A CLIENT: Look at the sample client mainSRDClient.cpp. The 
    API calls are listed in srd.h. To compile your client use the following
    in Makefile:

      client: mainSRDClient.o srd.o libsrd.a
	$(GCC) -g -o client mainSRDClient.o libsrd.a -lxml2
	
	A DESCRPTION OF THE API's IS GIVEN IN 'srd.h'
	
11) AN EXAMPLE of running TWO Daemons (south-side clients) with two separate Operational Data Stores specified
    using Name Spaces and ONE North-side Management Client sending XPath expression for the two Operational
    Data Stores. Execute the following commands:
    
    a) Open an XTerm window in the code directory and execute:
       cd server
       ./sysrepod param
    b) Open another XTerm window in the code directory and execute:
       cd client_SRD
       ./opDStoreSubTree1
    c) Open another XTerm window in the code directory and execute:
       cd client_SRD
       ./opDStoreSubTree2
       
       b) and c) starr two Daemons that register two Operational Data Stores
       Now let us start a north-side client to send XPATH to these two Daemons
    d) Open another XTerm window in the code directory and execute:
       cd client_SRD
       ./opDStoreGetSubTree
       
       You will see the results of XPath in this XTerm window.
  
 12) INSTRUCTIONS to run a performance test on a huge data store with 20,000 xml nodes and a query that retrieves
       
    You will see that the query is answered in an instant. The reply is calculated, transmitted, and parsed in milli-seconds.
       
      1000 XML nodes in the result.
      
    a) To generate a large XML file with name huge.xml, run the following command:
       cd server
       ./genHuge
       
    b) To start server, execute:
       ./sysrepod param 
       
    c) To start a client that sends a XPATH query to retreive 1000 nodes, run the commands:
       Open another XTERM window
       cd client_SRD
       ./hugeTest
       
    You will see that the query is answered in an instant. The reply is calculated, transmitted, and parsed in milli-seconds.
    You can change parameters defined in the progream server/mainHugeTest.c to generate arbitrarily large xml in huge.xml
    and just follow the same instructions to execute XPATH to check the performance of SYSREPOD server.     

       
 13) INSTRUCTIONS to run a signal test: SIGHUP is registed with the server by a client. 
    It causes the server to send the signal to the client whenever the Data Store is modified.
       
    a) To start server, execute:
       cd server
       ./sysrepod param 
       
    c) To start a client that registers SIGHUP and is ready to receive it, run the commands:
       Open another XTERM window
       cd client_SRD
       ./signalTest
       
 14) INSTRUCTIONS to run an XSLT test: It applies an XSLT to the data store and prints results.
     This XSLT filters all LEAF nodes and prints "name" and "value" pairs separated by ':' on
     a separate line. XSLT's can be used to generate XML, HTML, and flat data suitable for consumption
     by conventional program like SSHD.
     Note that XSLT must be enclosed within CDATA clause.
       
    a) To start server, execute:
       cd server
       ./sysrepod param 
       
    c) To start this client to apply XSLT on the data store, run the commands:
       Open another XTERM window
       cd client_SRD
       ./xsltTest

 15) SEMANTIC CONSTRAINTS USING XSLT: An example of a semantic constraint is that the number of
     <interface> nodes must be greater than 1. Arbitrarily complex semantic constraints can
     be expressed using XSLT as it is a full-fledged programming language. We assume that XSLT
     generates <ok/> xml if the constraints are met. If constraints are not met, the generated xml
     should not contain <ok/> node. Constriaints are expressed by a third parameter in the parameter
     file within the line defining a data store. For example:

        DATASTORE runtime deviceConfig.xml checkDir; 

     defines a data store 'runtime', its XML, and the third parameter is a directory path 'checkDir'.
     Since, the current dir for server is './server', 'checkDir' exists under './server'.
     This dir may contains XSD, DSDL & XSLT files specifying Data Store's syntactic and semantic 
     contraints (all files in one directory). In the dir, the file extensions will tell the server 
     what to do with them. Note that this third parameter, a dir path, is optional.

     Currently, only the processing of XSLT is implemented. 'checkDir' contains one sample XSL file
     checking that the data store must have at least one 1 <interface> node. For a -ve test, you can
     edit this XSL file and replace 8th line with the following line:

         <xsl:when test="$num &gt; 3">

     This new line expresses that the number of <interface> nodes must be more than 3. With the given XML 
     for 'runtime' data store, this constraint will fail and server will not create the data store
     printing the following error message:

        XSL sheet checkDir/deviceConfigSemanticCheck.xsl generated semantic error.
        Warning: Constraints failed. Data store will not be created.
        Warning in creating a new data store: runtime
        Warning: Could not add data store runtime

     To test the semantic constraints, run the following command:
         cd server
         ./sysrepod param

     The constrains checks will also be performed when a client modifies the data store using API.
     Another way to check this constraint is by trying to remove both <interface> nodes present
     in 'runtime' data store. The attempt should fail. There is a sample program to test constraint
     failure via API. To run this example, follow the instructions:
         To run server, "cd server" and execute "./sysrepod param". In another xterm window, type:
         cd client_SRD
         ./deleteNodeConstraintFailTest
     You will semantic constraint violation. No changes will be made to 'runtime' data store.

16)  SEMANTIC CONSTRAINTS USING YANG: Semantic constraints are expressed in a Yang model. 
     Pyang and Jing tools are used to apply these semantic contraints when the data store is 
     created or modified. To install these tools, use the following commands:

     sudo apt-get install jing
     git clone git://github.com/mbj4668/pyang.git

     To set environment variables for Pyang and run sysrepod, use the following commands:
     
     cd <pyang-dir>
     ./env.sh
     cd <sysrepod/server>
     ./sysrepod param

     To use Yang based constraint verification, let us consider the following in the server/param
     file:

     DATASTORE sshd_config  sshd---config.xml  xsltDir  yangDirFor_sshd_config;

     Here, ssh_config is the name of the data store to be created.
     sshd---config.xml is used to create the contents of the data store.
     xslDir may be used to store a set of XSL files for custom constraint verification.
     Create xslDir directory under 'server'.
     'yangDirFor_sshd_config' directory is created to store a yang model for 'sshd_config' data store.
     The name of the file must be '<dataStore Name>.yang'. In this case, it would be 
     'sshd_config.yang'. 

     Now 'sshd_config' data store is ready for yang based constrained verification. There is an example
     implemented in 'client_SRD/mainYangTest.c' file. This example, tries to add a new node that
     violates yang model. After starting sysrepod server as mentioned above, start the client to
     test yang model using the following command:

     cd client_SRD
     ./yangTest

     The test will report that the act of adding a new node failed as it violates constraints. 

     NOTE that there may be many constraints that can not be expressed in Yang Model. One can use
     XSLT based constraints as described under 15) above to express any constraint.
